;; When running openqa in a script, org might not be loaded yet
(require 'org)

(defcustom openqa-dotfiles-folder "~/.dotfiles"
  "The folder where dotfiles and org-mode configuration files are stored."
  :type 'string
  :group 'dotfiles)

(defcustom openqa-output-directory "~"
  "The directory where openqa.el will write out your dotfiles.
This is typically set to the home directory but can be changed
for testing purposes."
  :type 'string
  :group 'dotfiles)

(defcustom openqa-org-files '()
  "The list of org-mode files under the `openqa-dotfiles-folder'
which contain configuration files that should be tangled"
  :type '(list string)
  :group 'dotfiles)

(defcustom openqa-config-files-directory ".files"
  "The directory path inside of `openqa-dotfiles-folder' where
configuration files that should be symbolically linked are stored."
  :type 'string
  :group 'dotfiles)

(defcustom openqa-ensure-output-directories '(".config" ".local/share")
  "List of directories in the output folder that should be created
before linking configuration files."
  :type  '(list string)
  :group 'dotfiles)

(defcustom openqa-tangle-on-save t
  "When t, automatically tangle Org files on save."
  :type 'boolean
  :group 'dotfiles)

(defcustom openqa-keymap-prefix "C-c C-."
  "The prefix for openqa-mode key bindings."
  :type 'string
  :group 'dotfiles)

(defvar openqa-gitignore-marker "\n# -- Generated by openqa.el! --\n\n"
  "The marker string to be placed in the .gitignore file of the
dotfiles repo to indicate where the auto-generated list of ignored
files begins.")

(defun openqa--scan-for-output-files (org-file)
  (let ((output-files '())
	(current-match t))
    ;; Get a buffer for the file, either one that is
    ;; already open or open a new one
    (with-current-buffer (or (get-file-buffer org-file)
			     (find-file-noselect org-file))
      ;; Save the current buffer position
      (save-excursion
	;; Go back to the beginning of the buffer
	(goto-char (point-min))

	;; Loop until no more matches are found
	(while current-match
	  ;; Search for blocks with a :tangle property
	  (setq current-match (search-forward ":tangle " nil t))
	  (when current-match
	    (let ((output-file (thing-at-point 'filename t)))
	      ;; If a file path was found, add it to the list
	      (unless (or (not output-file)
			  (string-equal output-file "no"))
		(setq output-files (cons output-file
					 output-files))))))))
    output-files))

(defun openqa--update-gitignore ()
  (let ((output-files '()))
    ;; Gather the list of output files from all Org files
    (dolist (org-file openqa-org-files)
      (setq output-files
	    (append output-files
		    (openqa--scan-for-output-files
		     (expand-file-name org-file openqa-dotfiles-folder)))))

    ;; Now that we have the output files, update the .gitignore file
    (let ((gitignore-file (expand-file-name ".gitignore"
					    openqa-dotfiles-folder)))
      ;; Find the .gitignore buffer and prepare for editing
      (with-current-buffer (or (get-file-buffer gitignore-file)
			       (find-file-noselect gitignore-file))
	(save-excursion
	  ;; Find or insert the openqa-gitignore-marker
	  (beginning-of-buffer)
	  (or (progn
		(search-forward openqa-gitignore-marker nil t))
	      (progn
		(end-of-buffer)
		(insert "\n" openqa-gitignore-marker)))

	  ;; Delete the rest of the buffer after the marker
	  (delete-region (point) (point-max))

	  ;; Insert a line for each output file
	  (dolist (output-file output-files)
	    (insert output-file "\n"))

	  ;; Make sure the buffer is saved
	  (save-buffer))))))

(defun openqa-tangle-org-file (&optional org-file)
  "Tangles a single .org file relative to the path in
dotfiles-folder.  If no file is specified, tangle the current
file if it is an org-mode buffer inside of dotfiles-folder."
  (interactive)
  ;; Suppress prompts and messages
  (let ((org-confirm-babel-evaluate nil)
	(message-log-max nil)
	(inhibit-message t))
    (org-babel-tangle-file (expand-file-name org-file openqa-dotfiles-folder))
    ;; TODO: Only update files that are generated by this file!
    (openqa-link-config-files)))

(defun openqa-tangle-org-files ()
  "Tangles all of the .org files in the paths specified by the variable dotfiles-folder"
  (interactive)
  (dolist (org-file openqa-org-files)
    (openqa-tangle-org-file org-file))
  (message "Dotfiles are up to date!"))

(defun openqa--resolve-config-files-path ()
  (expand-file-name openqa-config-files-directory
		    openqa-dotfiles-folder))

(defun openqa--link-config-file (config-file)
  ;; Get the "path parts", basically the name of each directory and file in the
  ;; path of config-file
  (let* ((path-parts
	  (split-string (file-relative-name (expand-file-name config-file)
					    (openqa--resolve-config-files-path))
			"/" t))
	 (current-path nil))
    ;; Check each "part" of the path to find the right place to create the symlink.
    ;; Whenever path-parts is nil, stop looping!
    (while path-parts
      ;; Create the current path using the first part and remove it from the
      ;; front of the list for future iterations
      (setq current-path (if current-path
			     (concat current-path "/" (car path-parts))
			   (car path-parts)))
      (setq path-parts (cdr path-parts))

      ;; Figure out whether the current source path can be linked to the target path
      (let ((source-path (expand-file-name (concat openqa-config-files-directory "/" current-path)
					   openqa-dotfiles-folder))
	    (target-path (expand-file-name current-path openqa-output-directory)))
	;; If the file or directory exists, is it a symbolic link?
	(if (file-symlink-p target-path)
	    ;; If the symbolic link exists, does it point to the source-path?
	    (if (not (string-equal source-path (file-truename target-path)))
		(error "Path already exists with different symlink! %s" target-path)
	      ;; Clear path-parts to stop looping
	      (setq path-parts '()))
	  ;; If the target path is an existing directory, we need to keep
	  ;; looping, otherwise we can create a symlink here!
	  ;; Otherwise, the file is probably a directory so keep looping
	  (when (not (file-directory-p target-path))
	    ;; Create a symbolic link to the source-path and
	    ;; clear the path-parts so that we stop looping
	    (make-symbolic-link source-path target-path)
	    (setq path-parts '())))))))

(defun openqa-link-config-files ()
  (interactive)
  (let ((config-files
	 (directory-files-recursively
	  (openqa--resolve-config-files-path)
	  "")))
    ;; Ensure that the expected output directories are already
    ;; created so that links will be created inside
    (dolist (dir openqa-ensure-output-directories)
      (make-directory (expand-file-name dir openqa-output-directory) t))

    ;; Link all of the source config files to the output path
    (dolist (file config-files)
      (openqa--link-config-file file))))

(defun openqa-move-to-config-files (source-path)
  "Move a file from the output path to the configuration path."
  (interactive "FConfiguration path to move: ")
  (let* ((relative-path (file-relative-name (expand-file-name source-path)
					    openqa-output-directory))
	 (dest-path (expand-file-name relative-path
				      (openqa--resolve-config-files-path)))
	 ;; Strip any trailing slash so that we can treat the directory as file
	 (dest-path (if (string-suffix-p "/" dest-path)
			(substring dest-path 0 -1)
		      dest-path)))
    ;; Make sure that the path is under the output directory and that it
    ;; doesn't already exist
    (when (string-prefix-p ".." relative-path)
      (error "Copied path is not inside of config output directory: %s" openqa-output-directory))
    (when (file-exists-p dest-path)
      (error "Can't copy path because it already exists in the configuration directory: %s" dest-path))

    ;; Ensure that parent directories exist and then move the file!
    (make-directory (file-name-directory dest-path) t)
    (rename-file source-path dest-path)

    ;; Relink the path back to the output directory
    (openqa--link-config-file dest-path)))

(defun openqa-update-dotfiles ()
  "Generate and link configuration files to the output directory.
This command handles the full process of \"tangling\" Org Mode
files containing configuration blocks and creating symbolic links
to those configuration files in the output directory, typically
the user's home directory."
  (interactive)
  (openqa-tangle-org-files)
  (openqa-link-config-files)
  (openqa--update-gitignore))

(defun openqa--org-mode-hook ()
  (add-hook 'after-save-hook #'openqa--after-save-handler nil t))

(defun openqa--after-save-handler ()
  (when (and openqa-mode
	     openqa-tangle-on-save
	     (member (file-name-nondirectory buffer-file-name) openqa-org-files)
	     (string-equal (directory-file-name (file-name-directory (buffer-file-name)))
			   (directory-file-name (expand-file-name openqa-dotfiles-folder))))
    (message "Tangling %s..." (file-name-nondirectory buffer-file-name))
    (openqa-tangle-org-file buffer-file-name)))

(defun openqa--key (key)
  (kbd (concat openqa-keymap-prefix " " key)))

(define-minor-mode openqa-mode
  "Toggles global openqa-mode."
  nil
  :global t
  :group 'dotfiles
  :lighter " openqa"
  :keymap
  (list (cons (openqa--key "t") #'openqa-tangle-org-file)
	(cons (openqa--key "u") #'openqa-update-dotfiles))
  (if openqa-mode
      (add-hook 'org-mode-hook #'openqa--org-mode-hook)
    (remove-hook 'org-mode-hook #'openqa--org-mode-hook)))

(provide 'openqa)
